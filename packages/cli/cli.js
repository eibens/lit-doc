#!/usr/bin/env node
/*
const {execSync} = require('child_process')
const fs = require('fs')
const path = require('path')

const getYarnWorkspacesInfo = () => {
  const result = execSync('yarn workspaces info').toString('utf-8')
  const jsonStart = result.indexOf('{')
  const jsonEnd = result.lastIndexOf('}')
  const json = result.substr(jsonStart, jsonEnd - jsonStart + 1)
  const entries = JSON.parse(json, null)
  const keys = Object.keys(entries)
  return {entries, keys}
}

const getPackageInfo = location => {
  return JSON.parse(
    fs.readFileSync(
      path.join(location, 'package.json'),
      'utf-8'
    )
  )
}

const resolvePackageLocation = location => {
  // TODO: this only works for a monorepo with this particular structure
  return path.join(process.cwd(), '../..', location)
}

const buildDocs = () => {
  const docs = []
  const workspaces = getYarnWorkspacesInfo()
  workspaces.keys.forEach(key => {
    const workspace = workspaces.entries[key]
    const packageLocation = resolvePackageLocation(workspace.location)
    const packageInfo = getPackageInfo(packageLocation)
    const docPathRel = packageInfo.litDoc
    if (typeof docPathRel !== 'string') return
    const docPath = path.join(packageLocation, docPathRel)
    const src = fs.readFileSync(docPath, 'utf-8')
    docs.push({key, src})
  })
  return docs
}*/

const getPackageInfo = location => {
  return JSON.parse(
    fs.readFileSync(
      path.join(location, 'package.json'),
      'utf-8'
    )
  )
}



const docs = []

// language=ts
const generatedFile = `
// generated by lit-doc
// time: ${new Date()}

${docs.map(({key}, i) =>
  `import * as p${i} from '${key}'`
).join('\n')}

export default {
  ${docs.map(({key, src}, i) => `'${key}': {
    module: p${i},
    source: ${JSON.stringify(src)}
  }`).join('\n')}
}
`

const file = path.join(process.cwd(), 'lit.doc.ts')
fs.writeFileSync(file, generatedFile)
